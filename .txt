const repository = require('../repositories/usuarioRepository');
const bcrypt = require('bcrypt');

const MAX_TENTATIVAS = 5;
const TEMPO_BLOQUEIO_MINUTOS = 15;

class usuarioService {
    static async getAll() {
        const usuarios = await repository.getAll();
        return usuarios;
    }

    static async getById (id) {
        const usuarios = await repository.getById(id);
        return usuarios;
    }

    static async create (dados) {
        dados.password = await bcrypt.hash(dados.password, 10);
        const novoUsuario = await repository.create(dados);
        return novoUsuario;
    }

    static async update (id, dados) {
        if (dados.senha) {
            dados.senha = await bcrypt.hash(dados.senha, 10);
        }
        const usuarioAtualizado = await repository.update(id, dados);
        return usuarioAtualizado;
    }

    static async delete (id) {
        const usuarioDeletado = await repository.remove(id);
        return usuarioDeletado;
    }

    static async login (email, senha) {
        const usuario = await repository.getByEmail(email);

        if (!usuario) {
            throw { status: 401, message: 'Email ou senha incorretos' };
        }

        if (usuario.tempo_bloqueio && new Date(usuario.tempo_bloqueio) > new Date()) {
            const minutosRestantes = Math.ceil((new Date(usuario.tempo_bloqueio) - new Date()) / 60000);
            throw { status: 403, message: `Usuario bloqueado. Tente novamente em ${minutosRestantes} minutos.` }
        }

        const senhaValida = await bcrypt.compare(senha, usuario.password);
        if (!senhaValida) {
            await repository.incrementarTentativas(email);

            if ((usuario.tentativas_login || 0) + 1 >= MAX_TENTATIVAS) {
                repository.bloquearUsuario(email, TEMPO_BLOQUEIO_MINUTOS);
                throw { status: 403, message: `Usuario bloqueado por ${TEMPO_BLOQUEIO_MINUTOS} minutos devido a muitas tentativas.` };
        }
        throw { staus: 401, message: 'Email ou senha incorretos'};
    }

    await repository.resetarTentativas(email);

    return {
        message: 'login realizado com sucesso',
        usuario
    }
    };




}

module.exports = new usuarioService();

===========================================================

const usuarioService = require('../services/usuarioService');
const otpService = require('../services/otpService');

class UsuarioController {
    async getAll(req, res) {
        try {
            const usuarios = await usuarioService.getAll();
            res.status(200).json(usuarios);
        } catch (error) {
            console.error('Erro ao buscar usuarios', error);
            res.status(404).json({error: 'Erro ao buscar usuario '});
        }
    }

    async getById (req, res) {
        try {
            const { id } = req.params;
            const usuarios = await usuarioService.getById(id);
            
            if (!usuarios) {
                return res.status(404).json({ error: 'Usuario não encontrado' });
            }

            res.status(200).json(usuarios);
        } catch (error) {
            console.error('Erro ao buscar usuario', error);
            res.status(404).json({ error: 'Erro ao buscar usuario '});
        }
    }

    async create(req, res) {
        try {
            const usuario = req.body;
            const usuarios = await usuarioService.create(usuario);
            const token = jwt.sign(
                { id: usuarios.id, email: usuarios.email, nome: usuarios.nome },
                JWT_SECRET,
                { expiresIn: '1h' }
            );
            return res.status(201).json({message: 'Usuario criado com sucesso',token , usuario: usuarios});
        } catch (error) {
            if (error.message === 'Email já cadastrado') {
                return res.status(400).json({error: 'Email já cadastrado'});
            }
            console.error('Erro ao criar usuario', error);
            return res.status(400).json({error: 'Erro ao criar usuario'});
        }
    }

    async update(req, res) {
        try {
            const { id } = req.params;
            const usuario  = req.body;
            const usuarioAtualizado = await usuarioService.update(id, usuario);

            if (!usuarioAtualizado) {
                return res.status(404).json({ error: 'Usuario não encontrado' });
            }
            return res.status(200).json({message: 'Usuario atualizado com sucesso', usuario: usuarioAtualizado })
        } catch (error) {
            console.error('Erro ao atualizar usuario', error);
            return res.status(400).json({error: 'Erro ao atualizar usuario'});
        }
    }

    async delete(req, res) {
        try {
            const { id } = req.params;
            const usuarioDeletado = await usuarioService.delete(id);

            if (!usuarioDeletado) {
                return res.status(404).json({message: 'Usuario não encontrado para a remoção.'})
            } 

            return res.status(200).json({ message: 'Usuario deletado com sucesso', usuario: usuarioDeletado });
        } catch (error) {
            console.error('Erro ao removerusuario: ', error);
            return res.status(400).json({error: 'Erro ao remover usuario'});
        }
    }

        async solicitarOtp(req, res) {
            try {
                const { email } = req.body;                
                    if (!email) {
                        return res.status(400).json ({error: 'Email é obrigatorio'})
                    }
                await otpService.solicitarOtp(email);
                res.status(200).json({ message: 'OTP enviada para o seu e-mail'})
            } catch (error) {
                res.status(400).json({ erro: error.message });
            }
        }

    async verificarOtp(req, res) {
        try {
            const { email, otp } = req.body;
            const token = await otpService.verificarOtp(email, otp);
            return res.status(200).json({ token })
        } catch (error) {
            return res.status(400).json({ error: error.message})
        }
    }

    async login(req, res) {
        try {
            const { email, senha } = req.body;
            const result = await usuarioService.login( email, senha );
            res.status(200).json(resultado);
        } catch (error) {
            res.status(error.status || 500).json({ message: error.message || 'Erro ao efetuar login'});
        }
    }


}

module.exports = new  UsuarioController();

=================================================================================================

const db = require('../db/db');
const Usuario = require('../models/usuarioModel');

class UsuarioRepository {

    async getAll() {
        const result = await db.query(`SELECT * FROM usuario`);
        return result.rows.map(row => new Usuario(row));
    }
    async getById(id) {
        const result = await db.query(`SELECT * FROM usuario WHERE id = $1`, [id]);
        return result.rows[0] ? new Usuario(result.rows[0]) : null;
    }

    async getByEmail(email) {
        const result = await db.query('SELECT * FROM usuario WHERE email = $1' [email]);
        console.log("00000000")
        return result.rows[0]
    }
    async create({ nome, sobrenome, data_nascimento, email, password, historico_pontuacoes }) {
        // Verifica se já existe usuário com o mesmo email
        const existing = await db.query('SELECT * FROM usuario WHERE email = $1', [email]);
        if (existing.rows.length > 0) {
            throw new Error('Email já cadastrado');
        }
        // Define valor padrão se não enviado
        if (historico_pontuacoes === undefined) {
            historico_pontuacoes = {};
        }
        const result = await db.query(
            'INSERT INTO usuario (nome, sobrenome, data_nascimento, email, password, historico_pontuacoes) VALUES ($1, $2, $3, $4, $5, $6) RETURNING *',
            [nome, sobrenome, data_nascimento, email, password, historico_pontuacoes]
        );
        return new Usuario(result.rows[0]);
    }
    async update(id, dados) {
        // Busca o usuário atual
        const usuarioAtual = await this.getById(id);
        if (!usuarioAtual) return null; 

        // Usa os dados enviados ou mantém os antigos
        const nome = dados.nome ?? usuarioAtual.nome;
        const sobrenome = dados.sobrenome ?? usuarioAtual.sobrenome;
        const data_nascimento = dados.data_nascimento ?? usuarioAtual.data_nascimento;
        const email = dados.email ?? usuarioAtual.email;
        const password = dados.password ?? usuarioAtual.password;
        const historico_pontuacoes = dados.historico_pontuacoes ?? usuarioAtual.historico_pontuacoes;

        const result = await db.query(
            'UPDATE usuario SET nome=$1, sobrenome=$2, data_nascimento=$3, email=$4, password=$5, historico_pontuacoes=$6 WHERE id=$7 RETURNING *',
            [nome, sobrenome, data_nascimento, email, password, historico_pontuacoes, id]
        );
        return new Usuario(result.rows[0]);
    }

    async remove(id) {  
        const result = await db.query('DELETE FROM usuario WHERE id = $1 RETURNING *', [id]);
        return result.rows[0] ? new Usuario(result.rows[0]) : null;
    }

    async incrementarTentativas(email) {
        await db.query(`
            UPDATE usuario 
            SET tentativas_login = tentativas_login + 1
            WHERE email = $1`, [email]);
    }

    async resetarTentativas(email) {
        await db.query(`
            UPDATE usuario
            SET tentativas_login = 0, tempo_bloqueio = null
            WHERE email = $1`, [email]);
    }

    async bloquearUsuario(email, tempoBloqueioMinutos) {
        await db.query(`
            UPDATE usuario
            SET tempo_bloqueio = NOW() + INTERVAL '${tempoBloqueioMinutos} minutes',
            tentativas_login = 0
            WHERE email = $1`, [email])
    }
}

module.exports = new UsuarioRepository();